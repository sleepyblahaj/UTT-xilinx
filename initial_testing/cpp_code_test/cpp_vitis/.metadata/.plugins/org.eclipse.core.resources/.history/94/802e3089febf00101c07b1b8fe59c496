/******************************************************************************
*
* Copyright (C) 2009 - 2014 Xilinx, Inc.  All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* Use of the Software is limited solely to applications:
* (a) running on a Xilinx device, or
* (b) that interact with a Xilinx device through a bus or interconnect.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
* XILINX  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
* OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*
* Except as contained in this notice, the name of the Xilinx shall not be used
* in advertising or otherwise to promote the sale, use or other dealings in
* this Software without prior written authorization from Xilinx.
*
******************************************************************************/

/*
 * helloworld.c: simple test application
 *
 * This application configures UART 16550 to baud rate 9600.
 * PS7 UART (Zynq) is not initialized by this application, since
 * bootrom/bsp configures it to baud rate 115200
 *
 * ------------------------------------------------
 * | UART TYPE   BAUD RATE                        |
 * ------------------------------------------------
 *   uartns550   9600
 *   uartlite    Configurable only in HW design
 *   ps7_uart    115200 (configured by bootrom/bsp)
 */

#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"

uint8_t board_checker(uint8_t board[3][3]){
    int tie = 1;
    uint8_t status;
    uint8_t line;

    /* check for a tie */
    for(int i = 0; i < 3; i++){
        for(int j = 0; j < 3; j++){
            if(board[i][j] == 0){
                tie = 0;
            }
        }
    }
    if (tie == 1){
        return 1;
    }
    if(board[0][0] != 0 && board[0][0] == board[1][1] && board[1][1] == board[2][2]) {
        status = board[0][0];
        return status;
    }
    if(board[0][2] != 0 && board[0][2] == board[1][1] && board[1][1] == board[2][0]) {
        status = board[0][2];
        return status;
    }
    for(int column = 0; column < 3; column++)
    {
        if(board[0][column] == board[1][column]
                && board[0][column] != 0
                && board[1][column] == board[2][column]) {
            status = board[0][column];
            return status;
        }
    }
    for(int row = 0; row < 3; row++)
    {
        if(board[row][0] != 0 && board[row][0] == board[row][1] && board[row][1] == board[row][2]) {
            status = board[row][0];
            return status;
        }
    }
    return 0;


}
/*
uint8_t win_loc_checker(uint8_t[3][3] board){
    uint8_t line;
    if(board[0][0] != 0 &&
       board[0][0] == board[1][1] &&
       board[1][1] == board[2][2]) {
        line = 64;
        return line;
    }
    if(board[0][2] != 0 &&
       board[0][2] == board[1][1] &&
       board[1][1] == board[2][0]) {
        line=70;
        return line;
    }
    for(uint8_t column = 0; column < 3; column++)
    {
        if(board[0][column] == board[1][column]
                && board[0][column] != 0
                && board[1][column] == board[2][column]) {
            line = column << 4;
            line = line | 192;
            return line;
        }
    }
    for(int row = 0; row < 3; row++)
    {
        if(board[row][0] != 0
            && board[row][0] == board[row][1] \
            && board[row][1] == board[row][2]) {
            line = row << 4;
            line = line | 128;
            return line;
        }
    }
    return 0;
}
*/
uint8_t sub_turn(uint8_t board[3][3], uint8_t cell, uint8_t turn){
    if(board[cell/3][cell%3] == 0) {
        board[cell/3][cell%3] = turn;
        return 1;
    }
    return 0;

}

void display_boards(uint8_t print_board[3][3][3][3]){
    uint8_t current;
    char print_conversion;
    printf("\n \n");

    for(uint8_t w = 0; w<3; w++){
        for(uint8_t x = 0; x<3; x++){
            printf("\t");
            for(uint8_t y = 0; y<3; y++){
                for(uint8_t z = 0; z<3; z++){
                    current = print_board[w][y][x][z];
                    if(current == 2){
                        print_conversion = "X";
                    }
                    else if(current == 3){
                        print_conversion = "O";
                    }
                    else{
                        print_conversion = "_";
                    }
                    printf("%c" print_conversion);
                }
                printf("\t");
            }
            printf("\n");
        }
        printf("\n");
    }
    printf("\n \n");
}

void run_game(){
    uint8_t turn = 2;

    uint8_t total_board [3][3][3][3];
    uint8_t big_board[3][3];
    uint8_t big_status;

    uint8_t active_board;
    uint8_t active_cell;

    uint8_t status;

    uint8_t new_board_flag;

    new_board_flag = 0;

    printf("Enter the board number to start with: ");
    scanf("%d", &active_board);


    for(uint8_t i = 0; i<3;i++){
        for(uint8_t j = 0; j<3;j++){
            for(uint8_t k = 0; k<3;k++){
                for(uint8_t l = 0; l<3;l++){
                    total_board[i][j][k][l] = 0;
                }
            }
        }
    }

    display_boards(total_board);


    while(1==1){

        if(new_board_flag == 1){
            printf("target board is full, select somewhere else");
            scanf("%d", active_board);
            if(big_board[active_board/3][active_board%3] !=0){
                continue;
            }
            new_board_flag = 0;
        }

        for(uint8_t i = 0; i<3;i++){
            for(uint8_t j = 0; j<3;j++){
                big_board[i][j] = board_checker(total_board[i][j]);
            }
        }
        big_status = board_checker(big_board);
        if (big_status != 0){
            printf("The winner is: %d", (big_status-1));
            break;
        }

        printf("Player %d select cell", (turn -1));

        scanf("%d", active_cell);

        status = sub_turn(total_board[active_board/3][active_board%3], active_cell, turn);
        if(status =0){
            printf("cell is occupied, try again");
            continue;
        }




        if(turn == 2){
            turn = 3;
        }
        else{
            turn = 2;
        }
        active_board = active_cell;
        if(big_board[active_board/3][active_board%3] !=0){
            new_board_flag = 1;
        }
    }

}

int main()
{
    init_platform();

    run_game();
    cleanup_platform();
    return 0;
}

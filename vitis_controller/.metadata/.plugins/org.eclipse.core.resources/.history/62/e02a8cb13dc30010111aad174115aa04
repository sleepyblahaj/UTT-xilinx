#include <stdio.h>
#include "xil_printf.h"
#include "hdmi_text_controller.h"
#include "stdio.h"
#include "string.h"
#include "sleep.h"



uint8_t board_checker(uint8_t board[3][3]){
    int tie = 1;
    uint8_t status;
    uint8_t line;

    /* check for a tie */
    for(int i = 0; i < 3; i++){
        for(int j = 0; j < 3; j++){
            if(board[i][j] == 0){
                tie = 0;
            }
        }
    }
    if (tie == 1){
        return 1;
    }
    if(board[0][0] != 0 && board[0][0] == board[1][1] && board[1][1] == board[2][2]) {
        status = board[0][0];
        return status;
    }
    if(board[0][2] != 0 && board[0][2] == board[1][1] && board[1][1] == board[2][0]) {
        status = board[0][2];
        return status;
    }
    for(int column = 0; column < 3; column++)
    {
        if(board[0][column] == board[1][column]
                && board[0][column] != 0
                && board[1][column] == board[2][column]) {
            status = board[0][column];
            return status;
        }
    }
    for(int row = 0; row < 3; row++)
    {
        if(board[row][0] != 0 && board[row][0] == board[row][1] && board[row][1] == board[row][2]) {
            status = board[row][0];
            return status;
        }
    }
    return 0;


}

uint8_t win_loc_checker(uint8_t board[3][3]){
    uint8_t line;
    if(board[0][0] != 0 &&
       board[0][0] == board[1][1] &&
       board[1][1] == board[2][2]) {
        line = 64;
        return line;
    }
    if(board[0][2] != 0 &&
       board[0][2] == board[1][1] &&
       board[1][1] == board[2][0]) {
        line=70;
        return line;
    }
    for(uint8_t column = 0; column < 3; column++)
    {
        if(board[0][column] == board[1][column]
                && board[0][column] != 0
                && board[1][column] == board[2][column]) {
            line = column << 4;
            line = line | 192;
            return line;
        }
    }
    for(int row = 0; row < 3; row++)
    {
        if(board[row][0] != 0
            && board[row][0] == board[row][1] \
            && board[row][1] == board[row][2]) {
            line = row << 4;
            line = line | 128;
            return line;
        }
    }
    return 0;
}

uint8_t sub_turn(uint8_t board[3][3], uint8_t cell, uint8_t turn){
    if(board[cell/3][cell%3] == 0) {
        board[cell/3][cell%3] = turn;
        return 1;
    }
    return 0;

}

void display_boards(uint8_t print_board[3][3][3][3]){
    uint8_t current;

    xil_printf("\n \n");

    for(uint8_t w = 0; w<3; w++){
        for(uint8_t x = 0; x<3; x++){
            xil_printf("\t");
            for(uint8_t y = 0; y<3; y++){
                for(uint8_t z = 0; z<3; z++){
                    current = print_board[w][y][x][z];
                    if(current == 2){
                        xil_printf("X");
                    }
                    else if(current == 3){
                    	xil_printf("O");
                    }
                    else{
                    	xil_printf("_");
                    }
                }
                xil_printf("\t");
            }
            xil_printf("\n");
        }
        xil_printf("\n");
    }
    xil_printf("\n \n");
}

void data_storer(uint8_t complete_board[3][3][3][3], uint8_t meta_board[3][3], uint8_t active_cell, uint8_t active_board, uint8_t reselect_flag, uint8_t big_status){
	uint32_t base;
	uint32_t address;
	uint32_t data;
	uint8_t temp_cell;
	uint8_t temp_board;
    for(uint8_t i = 0; i<3;i++){
        for(uint8_t j = 0; j<3;j++){
        	if(active_board == (i*3+j) || reselect_flag){
        		temp_board = 1;
        		temp_cell = active_cell;
        	}
        	else{
        		temp_board = 0;
        		temp_cell = 255;
        	}


         	base = (uint32_t)((i*3+j)*4);

           	address = base;
           	data = (uint32_t)(complete_board[i][j][0][0])<<24 | (uint32_t)(complete_board[i][j][0][1]) << 16 | (uint32_t)(complete_board[i][j][0][2]) << 8 | (uint32_t)(complete_board[i][j][1][0]);
           	xil_printf("Address: %X, Data: %X \n", address, data);
           	hdmi_ctrl->CELLS[address] = data;
           	address += 1;
            data = (uint32_t)(complete_board[i][j][1][1])<<24 | (uint32_t)(complete_board[i][j][1][2]) << 16 | (uint32_t)(complete_board[i][j][2][0]) << 8 | (uint32_t)(complete_board[i][j][2][1]);
            xil_printf("Address: %X, Data: %X \n", address, data);
            hdmi_ctrl->CELLS[address] = data;
            address += 1;
            data = (uint32_t)(complete_board[i][j][2][2])<<24 | (uint32_t)(temp_cell) << 16 | (uint32_t)(temp_board)<<8 | (uint32_t)(meta_board[i][j]);
            xil_printf("Address: %X, Data: %X \n", address, data);
            hdmi_ctrl->CELLS[address] = data;
        }
    }
    data = (uint32_t)(big_status) | (uint32_t)(reselect_flag) << 24;
    xil_printf("Address:24 %, Data: %X \n", data);
    hdmi_ctrl->GAME_STATUS = data;

}

void run_game(){
    uint8_t turn = 2;

    uint8_t total_board [3][3][3][3];
    uint8_t big_board[3][3];
    uint8_t big_status;

    uint8_t active_board;
    uint8_t active_cell;

    uint8_t status;

    uint8_t new_board_flag;

    new_board_flag = 0;




    for(uint8_t i = 0; i<3;i++){
        for(uint8_t j = 0; j<3;j++){
            for(uint8_t k = 0; k<3;k++){
                for(uint8_t l = 0; l<3;l++){
                    total_board[i][j][k][l] = 0;
                }
            }
        }
    }

    display_boards(total_board);
    data_storer(total_board, big_board, active_cell, active_board, new_board_flag, big_status);

    xil_printf("Enter the board number to start with: \n");
    scanf("%hhu", &active_board);
    while(1==1){



        for(uint8_t i = 0; i<3;i++){
            for(uint8_t j = 0; j<3;j++){
                big_board[i][j] = board_checker(total_board[i][j]);
            }
        }
        big_status = board_checker(big_board);
        if (big_status != 0){
            xil_printf("The winner is: %d", (big_status-1));
            break;
        }
        if(new_board_flag == 1){
                    xil_printf("target board is full, select somewhere else \n");
                    scanf("%hhu", &active_board);
                    if(big_board[active_board/3][active_board%3] !=0){
                        continue;
                    }
                    new_board_flag = 0;
                }
        xil_printf("The active board is %d", (active_board));
        xil_printf("Player %d select cell \n", (turn -1));

        scanf("%hhu", &active_cell);

        status = sub_turn(total_board[active_board/3][active_board%3], active_cell, turn);
        if(status ==0){
            xil_printf("cell is occupied, try again \n");
            continue;
        }


        display_boards(total_board);
        data_storer(total_board, big_board, active_cell, active_board, new_board_flag, big_status);

        if(turn == 2){
            turn = 3;
        }
        else{
            turn = 2;
        }
        active_board = active_cell;
        if(big_board[active_board/3][active_board%3] !=0){
            new_board_flag = 1;
        }
    }

}

